// -------------------------------------------------------------
// 
// File Name: /home/mori/Downloads/tomori_fft/hdlsrc/fft_overlap_tomori/complexmult3_block5.v
// Created: 2025-04-26 11:44:22
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: complexmult3_block5
// Source Path: fft_overlap_tomori/FFT64_outMuxed/64pointFFTchan/FFT64/complexmult3
// Hierarchy Level: 3
// Model version: 3.27
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module complexmult3_block5
          (clk,
           reset,
           enb_1_64_0,
           x1_re,
           x1_im,
           In3_re,
           In3_im,
           Out1_re,
           Out1_im);


  input   clk;
  input   reset;
  input   enb_1_64_0;
  input   signed [21:0] x1_re;  // sfix22_En15
  input   signed [21:0] x1_im;  // sfix22_En15
  input   signed [17:0] In3_re;  // sfix18_En17
  input   signed [17:0] In3_im;  // sfix18_En17
  output  signed [21:0] Out1_re;  // sfix22_En15
  output  signed [21:0] Out1_im;  // sfix22_En15


  reg signed [21:0] Delay5_out1;  // sfix22_En15
  reg signed [17:0] Delay6_out1;  // sfix18_En17
  wire signed [39:0] Product1_out1;  // sfix40_En32
  reg signed [39:0] Delay1_reg [0:1];  // sfix40 [2]
  wire signed [39:0] Delay1_reg_next [0:1];  // sfix40_En32 [2]
  wire signed [39:0] Delay1_out1;  // sfix40_En32
  wire signed [21:0] Data_Type_Conversion1_out1;  // sfix22_En15
  reg signed [21:0] Delay13_out1;  // sfix22_En15
  reg signed [21:0] Delay7_out1;  // sfix22_En15
  reg signed [17:0] Delay8_out1;  // sfix18_En17
  wire signed [39:0] Product2_out1;  // sfix40_En32
  reg signed [39:0] Delay2_reg [0:1];  // sfix40 [2]
  wire signed [39:0] Delay2_reg_next [0:1];  // sfix40_En32 [2]
  wire signed [39:0] Delay2_out1;  // sfix40_En32
  wire signed [21:0] Data_Type_Conversion2_out1;  // sfix22_En15
  reg signed [21:0] Delay14_out1;  // sfix22_En15
  wire signed [21:0] Add4_out1;  // sfix22_En15
  reg signed [21:0] Delay9_out1;  // sfix22_En15
  wire signed [31:0] Add20_add_cast;  // sfix32_En15
  wire signed [31:0] Add20_add_cast_1;  // sfix32_En15
  wire signed [31:0] Add20_add_temp;  // sfix32_En15
  wire signed [21:0] Add20_out1;  // sfix22_En15
  reg signed [21:0] Delay3_out1;  // sfix22_En15
  wire signed [31:0] Add1_add_cast;  // sfix32_En17
  wire signed [31:0] Add1_add_cast_1;  // sfix32_En17
  wire signed [31:0] Add1_add_temp;  // sfix32_En17
  wire signed [17:0] Add1_out1;  // sfix18_En16
  reg signed [17:0] Delay4_out1;  // sfix18_En16
  wire signed [39:0] Product_out1;  // sfix40_En31
  reg signed [39:0] Delay_reg [0:1];  // sfix40 [2]
  wire signed [39:0] Delay_reg_next [0:1];  // sfix40_En31 [2]
  wire signed [39:0] Delay_out1;  // sfix40_En31
  wire signed [21:0] Data_Type_Conversion_out1;  // sfix22_En15
  reg signed [21:0] Delay12_out1;  // sfix22_En15
  wire signed [21:0] Add3_out1;  // sfix22_En15
  reg signed [21:0] Delay10_out1;  // sfix22_En15
  reg signed [21:0] Delay11_out1;  // sfix22_En15
  wire signed [21:0] Add2_out1;  // sfix22_En15
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_1;  // int32
  reg signed [31:0] Delay2_t_0_0;  // int32
  reg signed [31:0] Delay2_t_1;  // int32
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay5_out1 <= x1_re;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay6_out1 <= In3_re;
        end
      end
    end



  assign Product1_out1 = Delay5_out1 * Delay6_out1;



  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd1; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg[Delay1_t_1] <= 40'sh0000000000;
        end
      end
      else begin
        if (enb_1_64_0) begin
          for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
            Delay1_reg[Delay1_t_0_0] <= Delay1_reg_next[Delay1_t_0_0];
          end
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[1];
  assign Delay1_reg_next[0] = Product1_out1;
  assign Delay1_reg_next[1] = Delay1_reg[0];



  assign Data_Type_Conversion1_out1 = Delay1_out1[38:17] + $signed({1'b0, Delay1_out1[16] & (( ~ Delay1_out1[39]) | (|Delay1_out1[15:0]))});



  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay13_out1 <= Data_Type_Conversion1_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay7_out1 <= x1_im;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay8_out1 <= In3_im;
        end
      end
    end



  assign Product2_out1 = Delay7_out1 * Delay8_out1;



  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        for(Delay2_t_1 = 32'sd0; Delay2_t_1 <= 32'sd1; Delay2_t_1 = Delay2_t_1 + 32'sd1) begin
          Delay2_reg[Delay2_t_1] <= 40'sh0000000000;
        end
      end
      else begin
        if (enb_1_64_0) begin
          for(Delay2_t_0_0 = 32'sd0; Delay2_t_0_0 <= 32'sd1; Delay2_t_0_0 = Delay2_t_0_0 + 32'sd1) begin
            Delay2_reg[Delay2_t_0_0] <= Delay2_reg_next[Delay2_t_0_0];
          end
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[1];
  assign Delay2_reg_next[0] = Product2_out1;
  assign Delay2_reg_next[1] = Delay2_reg[0];



  assign Data_Type_Conversion2_out1 = Delay2_out1[38:17] + $signed({1'b0, Delay2_out1[16] & (( ~ Delay2_out1[39]) | (|Delay2_out1[15:0]))});



  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay14_out1 <= Data_Type_Conversion2_out1;
        end
      end
    end



  assign Add4_out1 = Delay13_out1 - Delay14_out1;



  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay9_out1 <= Add4_out1;
        end
      end
    end



  assign Out1_re = Delay9_out1;

  assign Add20_add_cast = {{10{x1_re[21]}}, x1_re};
  assign Add20_add_cast_1 = {{10{x1_im[21]}}, x1_im};
  assign Add20_add_temp = Add20_add_cast + Add20_add_cast_1;
  assign Add20_out1 = Add20_add_temp[21:0];



  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay3_out1 <= Add20_out1;
        end
      end
    end



  assign Add1_add_cast = {{14{In3_re[17]}}, In3_re};
  assign Add1_add_cast_1 = {{14{In3_im[17]}}, In3_im};
  assign Add1_add_temp = Add1_add_cast + Add1_add_cast_1;
  assign Add1_out1 = Add1_add_temp[18:1] + $signed({1'b0, ( ~ Add1_add_temp[31]) & Add1_add_temp[0]});



  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 18'sb000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay4_out1 <= Add1_out1;
        end
      end
    end



  assign Product_out1 = Delay3_out1 * Delay4_out1;



  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd1; Delay_t_1 = Delay_t_1 + 32'sd1) begin
          Delay_reg[Delay_t_1] <= 40'sh0000000000;
        end
      end
      else begin
        if (enb_1_64_0) begin
          for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd1; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
            Delay_reg[Delay_t_0_0] <= Delay_reg_next[Delay_t_0_0];
          end
        end
      end
    end

  assign Delay_out1 = Delay_reg[1];
  assign Delay_reg_next[0] = Product_out1;
  assign Delay_reg_next[1] = Delay_reg[0];



  assign Data_Type_Conversion_out1 = Delay_out1[37:16] + $signed({1'b0, Delay_out1[15] & (( ~ Delay_out1[39]) | (|Delay_out1[14:0]))});



  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay12_out1 <= Data_Type_Conversion_out1;
        end
      end
    end



  assign Add3_out1 = Delay12_out1 - Delay13_out1;



  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay10_out1 <= Add3_out1;
        end
      end
    end



  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 22'sb0000000000000000000000;
      end
      else begin
        if (enb_1_64_0) begin
          Delay11_out1 <= Delay14_out1;
        end
      end
    end



  assign Add2_out1 = Delay10_out1 - Delay11_out1;



  assign Out1_im = Add2_out1;

endmodule  // complexmult3_block5

